# MYSQL 연동 방법
1. 드라이버 설치
  - MySQL DB API Drivers를 설치한다. `mysqlclient`와 `MySQL Connector/Python` 두 종류가 있는데 전자를 추천한다.
  - pip를 통해 설치한다.
```shell
py -m pip install mysqlclient
```

2. 데이터베이스 접속 정보 설정
  - 데이터베이스 종류, 데이터베이스 이름, 접속할 때 사용할 사용자 이름, 비밀번호 등을 설정한다.
```python
# settings.py
DATABASES = {
    'default' : {
        'ENGINE': 'django.db.backends.mysql',  # 데이터베이스 종류.
        'NAME': 'myboard',  # 데이터베이스 이름.
        'USER': 'root',  # 접속할 때 사용할 사용자 이름.
        'PASSWORD': 'password',  # 비밀번호
        'HOST': 'localhost',  # 데이터베이스가 위치한 컴퓨터의 IP 주소.
        'PORT': '3306',  # 포트 번호.
    }
}
```
또는,
```python
# settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'OPTIONS': {
            'read_default_file': str(BASE_DIR / 'my.cnf'),
        },
    },
}
# my.cnf
[client]
database = myboard
user = root
password = 1234
default-character-set = utf8
```

3. 데이터베이스 접속
  - 테이블을 직접 만들거나 모델 작성 후 `migrate` 명령어를 통해 자동으로 생성한다.
  - 모델의 설정대로 데이터베이스의 테이블을 조작할 수 있다.

***

# 템플릿/정적 파일 공통 경로 설정
- 템플릿/정적 파일을 저장하는 폴더는 각 앱 하위의 폴더로 설정하는 것도 가능하지만, 모든 앱이 공통으로 사용할 수 있게 상위 폴더를 생성하여 설정할 수도 있다.
1. 템플릿 파일
  - settings.py 파일에서 TEMPLATES 설정을 변경한다.
  - 설정한 경로에 폴더를 생성하여 템플릿 파일을 저장한다.
```python
# settings.py
TEMPLATES = [
    {
        ...
        'DIRS': [BASE_DIR / 'templates'],
        ...
    },
]
```

2. 정적 파일
  - settings.py 파일에서 STATICFILES_DIRS 설정을 변경한다.
  - 설정한 경로에 폴더를 생성하여 정적 파일을 저장한다.
```python
STATICFILES_DIRS = [
    BASE_DIR / 'static',
]
```

***

# 클래스 기반 뷰(Class-based View) 및 제네릭 뷰(Generic View)
- 함수를 사용해서 뷰를 만들 수도 있지만 클래스를 사용해서 또한 만들 수도 있으며, 이를 클래스 기반 뷰(Class-based View)라고 한다.
- 장고에서는 클래스 기반 뷰를 구현하기 위해 미리 만들어둔 클래스를 제공하며, 이를 제네릭 뷰(Generic View)라고 한다.
- 제공되는 클래스를 바로 사용할 수도 있고 상속하는 클래스를 만들어서 원하는대로 커스터마이징 할 수도 있다.
- 사용자 로그인 및 로그아웃은 django.contrib.auth.LoginView 및 LogoutView 클래스를 바로 사용했다.
- 사용자 등록, 정보 수정, 탈퇴는 django.views.generic.CreateView, UpdateView, DeleteView 클래스를 상속하는 클래스를 만들어서 사용했다.

***

# 폼(Form)
- 클래스 뷰에서 다룰 모델과 필드를 직접 지정할 수도 있고, 폼을 통해서 일괄적으로 지정 및 커스터마이징 할 수도 있다.

***

# django.contrib.auth.models.User
- 장고에서 기본적으로 제공하는 사용자 모델이다.
- 필수 필드로 username, password 필드가 있고, 그밖에도 선택적 필드로 first_name, last_name, email 등이 있다.
- 해당 모델을 기존의 뷰 또는 폼에서 사용할 수 있고, 혹은 상속하는 클래스를 작성하여 원하는 대로 커스터마이징 할 수도 있다.
- 항상 user 변수명으로 세션에 저장되어 있다.
- user.is_authenticated 속성을 통해 로그인 여부를 확인할 수 있다.
  - 로그인 뷰를 통해 로그인 한 사용자의 경우 True를 반환한다.
- 해당 모델을 지원하기 위해 LoginView, LogoutView, PasswordChangeView, PasswordChangeDoneView 등을 제공한다.
- 해당 모델을 지원하기 위해 UserCreationForm, UserChangeForm, PasswordChangeForm 등을 제공한다.

***

# 페이징
- 장고에서 제공하는 Paginator 클래스를 사용하여 페이징 기능을 구현할 수 있다.
- 클래스 뷰에서 paginated_by 속성을 작성하면 자동으로 Page 객체를 생성하여 템플릿으로 전달한다.
- 템플릿에서 사용할 수 있는 Page 객체의 속성은 다음과 같다.
  - page_obj: Page 객체.
    - page_obj.has_next: 다음 페이지가 있으면 True. 없으면 오류 발생.
    - page_obj.has_previous: 이전 페이지가 있으면 True.
    - page_obj.has_other_pages: 이전 혹은 다음 페이지가 있으면 True.
    - page_obj.next_page_number: 다음 페이지 번호.
    - page_obj.previous_page_number: 이전 페이지 번호.
    - page_obj.start_index: 이 페이지의 첫 번째 객체의 인덱스.
    - page_obj.end_index: 이 페이지의 마지막 객체의 인덱스.
    - page_obj.object_list: 이 페이지의 객체 목록.
    - page_obj.number: 이 페이지의 번호.
    - page_obj.paginator: 관련 Paginator 객체.
        {% with page_obj.paginator as paginator %}
        <ul>
            <li>paginator.object_list: 전체 페이지의 모든 객체 목록. {{ paginator.object_list }}</li>
            <li>paginator.per_page: 이 페이지의 최대 항목 수. {{ paginator.per_page }}</li>
            <li>paginator.count: 전체 페이지의 모든 객체 수. {{ paginator.count }}</li>
            <li>paginator.num_pages: 총 페이지 수. {{ paginator.num_pages }}</li>
            <li>paginator.page_range: 전체 페이지 range 객체. {{ paginator.page_range }}</li>
        </ul>
        {% endwith %}
    </li>
</ul>

검색
파일 업로드 및 다운로드